# lab1 datalab

### bitXor
要求：只用~和&实现异或xor

思路：通过一系列的变换找到 和 xor等价的表达式：

| (1)   | (2)   | |    (3)   | (4)   |   (5)   |  (6) |  | 
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
|     |     | XOR|    ~(1)   | ~(2)   |    (2)&(3)     |  (1)&(4) | (5)l(6)  | 
|  0  |   0 |    0 |    1|     1|       0|          0|         0 |
 |    0|     1|     1|     1|     0|       1|          0|         1|
 |    1|     0|     1|     0|     1|       0|          1|         1|
 |    1|     1|     0|     0|     0|       0|          0|         0|

即  x xor y = (y & ~x) | (x & ~y)

### tmin
要求：求 二的补码的最小的那个值
思路：10000000 00000000 00000000 00000000为所求
通过移位即可

### isTmax
要求：判断一个数是否为 二的补码的最大的那个值  
思路：寻找最大值的性质。  
当只有4位时，Tmax=0111  

Tmax+1+Tmax=1111  
Tmax+1+Tmax+1=0000  
 
但-1(1111)也有这个性质，为了和Tmax进行区别：  
当x==-1时, ~x=0000, !(~x)==false  
而!(~Tmax)=true  
 
### allOddBits
要求：判断一个数的奇数位 是否都是1  
思路：  
构造 a=   01010101 01010101 01010101 01010101  
    a|x= x1x1x1x1 x1x1x1x1 x1x1x1x1 x1x1x1x1  
如果a的奇数位都是1，那么  
    a|x= 11111111 11111111 11111111 11111111  

### negate
要求：对x的取负，输出-x
思路：用定义做即可。

### isAsciiDigit
要求：判断一个数x 是否有 0x30 <= x <= 0x39  
思路：  
0x30   0011 0000  
0x31   0011 0001  
0x32   0011 0010  
0x33   0011 0011  
0x34   0011 0100  
0x35   0011 0101  
0x36   0011 0110  
0x37   0011 0111  
他们都有这种格式：0011 0xxx   
 
然后再单独判断一下0x38 0x39即可  
0x38   0011 1000  
0x39   0011 1001  


### conditional
要求：如果 x！=0, 输出 y；如果 x==0, 输出 z  
思路：通过x构造一个k  
当x!=0时，k=11...1 输出y  
当x==0时，k=00...0 输出z  

那么结果就是：(k & y) | (~k & z)  

假设只有4位，构造过程如下：  

|   | x | 0 |  |  
| ------ | ------ | ------ |------ |  
| initial | xxxx | 0000 |(1)|
| (1)&1111 | x1xx | 0000 |(2)|
| !(2)  | 0000 | 0001 |(3)|
| (3)+1111 | 1111 | 0000 |k|

### isLessOrEqual
要求：如果x<=y，那么返回1，否则返回0.  
思路：  
如果  
x==y 或者  
x-y<0 且 (x-y) 不溢出，或者  
x<0 && y>0  
时，返回1  

### logicalNeg
要求：在不使用!的情况下，实现!  
思路：和conditional类似，通过x构造k  

假设只有4位时：  

当x是正数时，k=1111，输出0  
当x是0时，k=0000，输出1  
当x是负数时，k=1111，输出0  

k的构造过程： 

| ops | positive | 0 | negative |   |
| ------ | ------ | ------ |------ |------ |
|  initial |   0010|         0000|      1xxx|             (1)|
|  >>31    |   0000|         0000|      1111|             (2)|
 |  (1)+0111|   1xxx|         0111|      xxxx(unkown)|     (3)|
 |  (3)>>31 |   1111|         0000|      1111 or 0000|     (4)|
 |  (2)l(4) |   1111|         0000|      1111|             k  | 

### howManyBits
要求：求出某个数在二的补码表示时，最少需要多少位。  
思路：  
先写出只有4位时的表示情况：
  
| 值 | 二的补码 |
| ------ | ------ |
| 0|	0000|  
|1	|0001|
|2	|0010|
|3	|0011|
|4	|0100|
|5	|0101|
|6	|0110|
|7	|0111|
|-8	|1000|
|-7	|1001|
|-6	|1010|
|-5	|1011|
|-4	|1100|
|-3	|1101|
|-2	|1110|
|-1	|1111|

可以发现，0和-1、1和-2、2和-3...表示的个数相同。  
那可以先把数字都变成负的：x=~(x^(x>>31));  

然后遍历找出左边第1个不是1的位  

我的做法有点暴力，操作数目超过了90个ops了。实际上合理的做法是用2分法来做，在代码的注释部分给出。  


### floatScale2
要求：对浮点数f，求2*f  
具体做法请看代码  
### floatFloat2Int  
要求：对浮点数f，求int(f)  
具体做法请看代码  
### floatPower2  
要求：对整数x，求2^x的等价浮点数的表示。  
具体做法请看代码  

